[{"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/index.js":"1","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/theme.js":"2","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/reportWebVitals.js":"3","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/App.js":"4","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Topbar.js":"5","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Meme.js":"6","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/MemeHistory/index.js":"7","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/TemplateOverview/index.js":"8","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/TemplatePicker/index.js":"9","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Editor/index.js":"10","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/routing/PrivateRoute.js":"11","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/MemeGenerator.js":"12","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Information.js":"13","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Autoplay/index.js":"14","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/RegisterScreen/index.js":"15","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/LoginScreen/index.js":"16","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/ResetPasswordScreen/index.js":"17","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/ForgotPasswordScreen/index.js":"18","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/ImgFlipTemplates/index.js":"19","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Charts/index.js":"20"},{"size":702,"mtime":1614537512479,"results":"21","hashOfConfig":"22"},{"size":402,"mtime":1614537439233,"results":"23","hashOfConfig":"22"},{"size":362,"mtime":1607255855555,"results":"24","hashOfConfig":"22"},{"size":1560,"mtime":1614537396663,"results":"25","hashOfConfig":"22"},{"size":1297,"mtime":1614537331343,"results":"26","hashOfConfig":"22"},{"size":397,"mtime":1614536963969,"results":"27","hashOfConfig":"22"},{"size":5122,"mtime":1614533837426,"results":"28","hashOfConfig":"22"},{"size":2294,"mtime":1614536337437,"results":"29","hashOfConfig":"22"},{"size":14940,"mtime":1614536870325,"results":"30","hashOfConfig":"22"},{"size":20012,"mtime":1614532541305,"results":"31","hashOfConfig":"22"},{"size":630,"mtime":1614533573829,"results":"32","hashOfConfig":"22"},{"size":15630,"mtime":1614547053323,"results":"33","hashOfConfig":"22"},{"size":1159,"mtime":1614536946181,"results":"34","hashOfConfig":"22"},{"size":1201,"mtime":1614531500364,"results":"35","hashOfConfig":"22"},{"size":3354,"mtime":1614534675819,"results":"36","hashOfConfig":"22"},{"size":2675,"mtime":1614534638058,"results":"37","hashOfConfig":"22"},{"size":2749,"mtime":1614534770765,"results":"38","hashOfConfig":"22"},{"size":2027,"mtime":1614534855578,"results":"39","hashOfConfig":"22"},{"size":1637,"mtime":1614536280503,"results":"40","hashOfConfig":"22"},{"size":1752,"mtime":1614547053323,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"1tj7kwl",{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"44"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"44"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"71"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"44"},"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/index.js",[],["87","88"],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/theme.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/reportWebVitals.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/App.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Topbar.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Meme.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/MemeHistory/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/TemplateOverview/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/TemplatePicker/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Editor/index.js",["89"],"/**\n * This is the Component for the Editor Box in the Middle of the Webapp in which Meme Templates are selected into in order to be edited and saved as a Meme.\n */\n\n// React imports\nimport React, { useState, useEffect, useRef } from \"react\";\n\n// Material UI imports\nimport { Button, TextField } from \"@material-ui/core\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport ArrowBackIcon from \"@material-ui/icons/ArrowBack\";\nimport ArrowForwardIcon from \"@material-ui/icons/ArrowForward\";\nimport ArrowDownwardIcon from \"@material-ui/icons/ArrowDownward\";\nimport ArrowUpwardIcon from \"@material-ui/icons/ArrowUpward\";\n\n// Share Buttons | Source: https://www.npmjs.com/package/react-share\nimport {\n  EmailShareButton,\n  FacebookShareButton,\n  TwitterShareButton,\n  EmailIcon,\n  FacebookIcon,\n  TwitterIcon,\n} from \"react-share\";\n\n// Use styling for our Material UI elements\nconst useStyles = makeStyles((theme) => ({\n  button: {\n    margin: theme.spacing(1),\n  },\n}));\n\n/**\n * Editor Canvas: We create a Canvas with Black Background into which we set our different templates for Meme creation\n * Within this Canvas, we also add the Meme Texts.\n * After editing the Meme in the Canvas, the Canvas is exported and can be saved to the DB.\n * Source for Canvas Setup: https://www.youtube.com/watch?v=-AwG8yF06Po\n */\n\n// we pre-define the canvas width and height\nconst CANVAS_WIDTH = 500;\nconst CANVAS_HEIGHT = 500;\nconst maxCanvasWidth = 600;\n\n// Editor which contains the Canvas\nconst Editor = (props) => {\n  const { memeToEdit, handleReloadMemes } = props; // props for reaload functionalities which are also used in other components\n  const classes = useStyles(); // const classes is created, which refers to useStyles\n\n  const [image, setImage] = useState(null);\n  const [imageWidth, setImageWidth] = useState(0);\n  const [imageHeight, setImageHeight] = useState(0);\n  const [templates, setTemplates] = useState([]);\n\n  const canvas = useRef(null);\n  const [canvasWidth, setCanvasWidth] = useState(0);\n  const [canvasHeight, setCanvasHeight] = useState(0);\n\n  const formRef = useRef(); // accesing input element\n  const [memeTitle, setMemeTitle] = useState(\"\");\n\n  const [fontColor, setFontColor] = useState(\"white\"); // default font color\n  const [fontStyle, setFontStyle] = useState(\"30px Impact\"); // default font style\n  const [topText, setTopText] = useState(\"\"); // by default no text\n  const [topTextPosX, setTopTextPosX] = useState(CANVAS_WIDTH / 2);\n  const [topTextPosY, setTopTextPosY] = useState(CANVAS_HEIGHT * 0.1);\n  const [bottomTextPosX, setBottomTextPosX] = useState(CANVAS_WIDTH / 2);\n  const [bottomTextPosY, setBottomTextPosY] = useState(CANVAS_HEIGHT * 0.9);\n  const [bottomText, setBottomText] = useState(\"\");\n  const [additionalTextA, setAdditionalTextA] = useState(\"\");\n  const [additionalTextAPosX, setAdditionalTextAPosX] = useState(\n    CANVAS_HEIGHT / 2\n  );\n  const [additionalTextAPosY, setAdditionalTextAPosY] = useState(\n    CANVAS_WIDTH * 0.5\n  );\n  // Setter for Path to be shared in the share section\n  const [pathForSharing, setPathForSharing] = useState(\"\");\n  // Setter to check if a new meme Template is selected in order to hide Share Buttons before saving.\n  const [previousMeme, setPreviousMeme] = useState();\n  // Setter to adjust Meme text positions in relation to the selected Template size\n\n  // Fetching Templates through a backend request\n  useEffect(() => {\n    fetch(\"http://localhost:3001/memes\")\n      .then((x) => x.json())\n      .then((response) => setTemplates(response.data.memes));\n  }, []);\n\n  const setDefaultTextPosition = () => {\n    setTopTextPosX(canvasWidth / 2);\n    setTopTextPosY(canvasHeight * 0.1);\n    setBottomTextPosX(canvasWidth / 2);\n    setBottomTextPosY(canvasHeight * 0.9);\n    setAdditionalTextAPosX(canvasWidth / 2);\n    setAdditionalTextAPosY(canvasHeight * 0.5);\n  };\n  // functionality to delete text\n  const deleteText = () => {\n    setTopText(\"\");\n    setBottomText(\"\");\n    setAdditionalTextA(\"\");\n  };\n\n  // Handle Input for the Meme Title provided by the User\n  const handleTitleInput = (e) => {\n    const title = e.target.value;\n\n    if (handleTitleInput) {\n      const memeTitle = {\n        title: title,\n      };\n      setMemeTitle(memeTitle);\n    }\n  };\n\n  // Define functions with which the font colors and styles are changed OnClick => See Buttons at the bottom\n  const changeFontColorBlack = () => {\n    setFontColor(\"black\");\n  };\n  const changeFontColorWhite = () => {\n    setFontColor(\"white\");\n  };\n  const changeFontBold = () => {\n    setFontStyle(\"30px Impact\");\n  };\n  const changeFontItalic = () => {\n    setFontStyle(\"Italic 30px Impact\");\n  };\n  const changeFontStyle = () => {\n    setFontStyle(\"50px Impact\");\n  };\n\n  // Function to save Meme to DB (takes the exported Canvas)\n  // Takes bodyToSend to save it accoring to the DB Schema of \"Meme\"\n  const saveMemeFromEditorToDB = () => {\n    const bodyToSend = JSON.stringify({\n      url: memeToEdit.url,\n      exportedImage: exportCanvasAsImage(),\n      title: memeTitle.title,\n      topText: topText,\n      bottomText: bottomText,\n      additionalTextA: additionalTextA,\n      topTextPosX: topTextPosX,\n      topTextPosY: topTextPosY,\n      bottomTextPosX: bottomTextPosX,\n      bottomTextPosY: bottomTextPosY,\n      additionalTextAPosX: additionalTextAPosX,\n      additionalTextAPosY: additionalTextAPosX,\n      fontStyle: fontStyle,\n      fontColor: fontColor,\n    });\n\n    // the upcoming fetch method sends the generated Meme (accessible through the new URL above) to the Express Backend Server. In the Express App, there is a route \"saveMeme\" in the Meme.js file that sends the URL with the generated Meme to the Server.\n    // This is the Feature from the \"API\" part \"create a single image with bottom/top text\"\n    fetch(\"http://localhost:3001/memes/saveMeme\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: bodyToSend,\n    })\n      .then((x) => x.json())\n      .then((response) => {\n        if (response) {\n          // After the user saves the Meme to DB, it is also saved in the public share folder and the filePath is provided for the share functionalities.\n          const { pathForSharing } = response;\n          setPathForSharing(\"http://localhost:3001\" + pathForSharing);\n          handleReloadMemes(true); // After a Meme is saved, the MemeHistory is realoaded with the newly saved Meme.\n        }\n      })\n      .catch((e) => console.log(\"e\", e));\n  };\n\n  // Here, we export the current content of the canvas to an image, so it can be dowloaded in the download function.\n  // The default file fize is 1 / 100%\n  // jpeg compression for maximum file size\n  // There are two download buttons, one normal and one \"compressed\" download button, which then sets the size to 10%\n  const exportCanvasAsImage = (size = 1) => {\n    const ctx = document.getElementById(\"meme-canvas\");\n    return ctx.toDataURL(\"image/jpeg\", size); // source: https://developer.mozilla.org/de/docs/Web/API/HTMLCanvasElement/toDataURL\n  };\n\n  // Function for downloading the created meme\n  const downloadMeme = (size = 1) => {\n    var link = document.createElement(\"a\");\n\n    const { title } = memeTitle; // The title of the meme to be downloaded is set\n    link.download = title;\n    link.href = exportCanvasAsImage(size);\n    console.log(\"exportCanvasAsImage\", exportCanvasAsImage);\n    link.click();\n  };\n\n  // Here, we set the \"Image\" which is the template to be edited for our Meme\n  useEffect(() => {\n    try {\n      if (!memeToEdit) return; // if there is no Template to edit, do nothing\n\n      const { url, filePath } = memeToEdit; // memeToEdit is the Meme Template that is set into the Editor\n      if (filePath) setPathForSharing(filePath); // Check if filePath is existing for sharing saved Meme\n      // Meme according to DB Schema\n      const meme = new Image();\n      meme.src = url;\n      meme.title = memeTitle;\n      meme.topText = topText;\n      meme.bottomText = bottomText;\n      meme.additionalTextA = additionalTextA;\n      meme.topTextPosX = topTextPosX;\n      meme.topTextPosY = topTextPosY;\n      meme.bottomTextPosX = bottomTextPosX;\n      meme.bottomTextPosY = bottomTextPosY;\n      meme.additionalTextAPosX = additionalTextAPosX;\n      meme.additionalTextAPosY = additionalTextAPosX;\n      meme.fontStyle = fontStyle;\n      meme.fontColor = fontColor;\n      // Directly load the selected meme\n      meme.onload = () => {\n        setImage(meme);\n        const { height, width } = meme;\n        // If the image size is bigger than the currently set canvas size, then adjust the image size according to the canvas maxWidth\n        if (width > maxCanvasWidth) {\n          setCanvasWidth(maxCanvasWidth);\n          setCanvasHeight((height * maxCanvasWidth) / width);\n          setImageHeight(maxCanvasWidth);\n          setImageWidth((height * maxCanvasWidth) / width);\n        } else {\n          setCanvasHeight(height);\n          setCanvasWidth(width);\n          setImageHeight(height);\n          setImageWidth(width);\n        }\n      };\n\n      meme.setAttribute(\"crossorigin\", \"anonymous\"); // Added this, so the url of the meme can be worked with.\n    } catch (error) {\n      console.log(\"error\", error);\n    }\n  }, [\n    additionalTextA,\n    additionalTextAPosX,\n    bottomText,\n    bottomTextPosX,\n    bottomTextPosY,\n    fontColor,\n    fontStyle,\n    memeTitle,\n    memeToEdit,\n    topText,\n    topTextPosX,\n    topTextPosY,\n  ]);\n  // ctx is the canvas that is created for the Editor\n  useEffect(() => {\n    if (image && canvas) {\n      const ctx = canvas.current.getContext(\"2d\"); // Build Canvas only if an image is selected\n\n      ctx.fillStyle = \"black\"; // the canvas is filled with black background color\n      ctx.fillRect(0, 0, canvasWidth, canvasHeight); // the canvas rectangle is filled according to the set width and height\n\n      const contentOffset = 10;\n      const factorWidth = canvasWidth / imageWidth;\n      const factorHeight = canvasHeight / imageHeight;\n\n      // drawImage is responsible for taking the image that the user selected and putting it on the Canvas (ctx). Source: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage\n      ctx.drawImage(\n        image,\n        contentOffset,\n        contentOffset,\n        imageWidth * factorWidth - contentOffset * 2,\n        imageHeight * factorHeight - contentOffset * 2\n      );\n\n      // set the font with which the text is entered in the Editor\n      ctx.font = fontStyle;\n      ctx.fillStyle = fontColor;\n      ctx.textAlign = \"center\";\n      // text edit options\n      ctx.fillText(topText, topTextPosX, topTextPosY);\n      ctx.fillText(bottomText, bottomTextPosX, bottomTextPosY);\n      ctx.fillText(additionalTextA, additionalTextAPosX, additionalTextAPosY);\n    }\n  }, [\n    image,\n    canvas,\n    topText,\n    bottomText,\n    additionalTextA,\n    topTextPosX,\n    topTextPosY,\n    bottomTextPosY,\n    bottomTextPosX,\n    additionalTextAPosX,\n    additionalTextAPosY,\n    imageWidth,\n    imageHeight,\n    fontColor,\n    fontStyle,\n    canvasHeight,\n    canvasWidth,\n  ]);\n\n  // Reset the path for sharing if the template has changed\n  // The user needs to save a meme from the Editor in order to receive a sharing link and make the sharing buttons visible\n  useEffect(() => {\n    if (image?.src !== previousMeme?.src) {\n      setPathForSharing(null);\n      setPreviousMeme(image);\n    }\n  }, [image, previousMeme]);\n\n  // Webapp interface of the Editor Component\n  return (\n    <div>\n      <div>\n        {/* User provided Title for the Meme */}\n        <TextField\n          style={{ width: 200 }}\n          size=\"small\"\n          type=\"text\"\n          name=\"URL\"\n          label=\"Meme Title\"\n          variant=\"outlined\"\n          ref={formRef}\n          onChange={handleTitleInput}\n        />\n      </div>\n      <br />\n      <div>\n        {image ? (\n          <canvas\n            id={\"meme-canvas\"}\n            ref={canvas}\n            width={canvasWidth}\n            height={canvasHeight}\n          />\n        ) : (\n          // if no image is selected, show the following message\n          <p>Select a Meme, please</p>\n        )}\n      </div>\n      <br />\n      {/* Set default text position according to the image size */}\n      <Button\n        variant=\"contained\"\n        color=\"primary\"\n        onClick={setDefaultTextPosition}\n        disabled={!image && true}\n        className={classes.button}\n      >\n        SET DEFAULT TEXT POSITION\n      </Button>\n      <Button\n        variant=\"contained\"\n        color=\"primary\"\n        onClick={deleteText}\n        disabled={!image && true}\n        className={classes.button}\n      >\n        DELETE TEXT\n      </Button>\n      <br />\n      <br />\n      <div>\n        {/* Input of text */}\n        <TextField\n          style={{ width: 200 }}\n          size=\"small\"\n          type=\"text\"\n          label=\"Upper text\"\n          variant=\"outlined\"\n          value={topText}\n          onChange={(e) => setTopText(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setTopTextPosX(topTextPosX - 10)}\n        >\n          <ArrowBackIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position X\"\n          value={topTextPosX}\n          onChange={(e) => setTopTextPosX(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setTopTextPosX(topTextPosX + 10)}\n        >\n          <ArrowForwardIcon />\n        </IconButton>\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setTopTextPosY(topTextPosY - 10)}\n        >\n          <ArrowUpwardIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position Y\"\n          value={topTextPosY}\n          onChange={(e) => setTopTextPosY(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setTopTextPosY(topTextPosY + 10)}\n        >\n          <ArrowDownwardIcon />\n        </IconButton>\n        <br />\n        <br></br>\n        <TextField\n          style={{ width: 200 }}\n          size=\"small\"\n          type=\"text\"\n          label=\"Bottom text\"\n          variant=\"outlined\"\n          value={bottomText}\n          onChange={(e) => setBottomText(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setBottomTextPosX(bottomTextPosX - 10)}\n        >\n          <ArrowBackIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position X\"\n          value={bottomTextPosX}\n          onChange={(e) => setBottomTextPosX(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setBottomTextPosX(bottomTextPosX + 10)}\n        >\n          <ArrowForwardIcon />\n        </IconButton>\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setBottomTextPosY(bottomTextPosY - 10)}\n        >\n          <ArrowUpwardIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position Y\"\n          value={bottomTextPosY}\n          onChange={(e) => setBottomTextPosY(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setBottomTextPosY(bottomTextPosY + 10)}\n        >\n          <ArrowDownwardIcon />\n        </IconButton>\n        <br />\n        <br></br>\n        <TextField\n          style={{ width: 200 }}\n          size=\"small\"\n          type=\"text\"\n          label=\"Additional Text A\"\n          variant=\"outlined\"\n          value={additionalTextA}\n          onChange={(e) => setAdditionalTextA(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setAdditionalTextAPosX(additionalTextAPosX - 10)}\n        >\n          <ArrowBackIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position X\"\n          value={additionalTextAPosX}\n          onChange={(e) => setAdditionalTextAPosX(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setAdditionalTextAPosX(additionalTextAPosX + 10)}\n        >\n          <ArrowForwardIcon />\n        </IconButton>\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setAdditionalTextAPosY(additionalTextAPosY - 10)}\n        >\n          <ArrowUpwardIcon />\n        </IconButton>\n        <TextField\n          style={{ width: 80 }}\n          size=\"small\"\n          type=\"text\"\n          variant=\"outlined\"\n          label=\"Position Y\"\n          value={additionalTextAPosY}\n          onChange={(e) => setAdditionalTextAPosY(e.target.value)}\n        />\n        <IconButton\n          size=\"large\"\n          variant=\"contained\"\n          onClick={(e) => setAdditionalTextAPosY(additionalTextAPosY + 10)}\n        >\n          <ArrowDownwardIcon />\n        </IconButton>\n      </div>\n      <br></br>\n      <div>\n        {/* Changing text format */}\n        <Button\n          size=\"small\"\n          variant=\"outlined\"\n          color=\"black\"\n          onClick={changeFontColorBlack}\n        >\n          Font: Black\n        </Button>\n        <Button size=\"small\" variant=\"outlined\" onClick={changeFontColorWhite}>\n          Font: White\n        </Button>\n        <Button size=\"small\" variant=\"outlined\" onClick={changeFontItalic}>\n          Font: Italic\n        </Button>\n        <Button size=\"small\" variant=\"outlined\" onClick={changeFontBold}>\n          Small Bold Font\n        </Button>\n        <Button size=\"small\" variant=\"outlined\" onClick={changeFontStyle}>\n          Bigger Bold Font\n        </Button>\n      </div>\n      <br></br>\n      <div>\n        {/* Save and Download Buttons */}\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          onClick={saveMemeFromEditorToDB}\n          disabled={!image && true}\n          className={classes.button}\n        >\n          SAVE MEME\n        </Button>\n\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          onClick={downloadMeme}\n          disabled={!image && true}\n          className={classes.button}\n        >\n          DOWNLOAD\n        </Button>\n\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          onClick={() => downloadMeme(0.1)} // The file fize is set to 10%. We have to define a function here, so downloadMeme takes the argument of 0.1 and sets the size to it.\n          disabled={!image && true}\n          className={classes.button}\n        >\n          DOWNLOAD COMPRESSED\n        </Button>\n      </div>\n      {/* Share Buttons: Show the share buttons only if there is a pathForSharing of if the pathForSharing String is not an Empty String */}\n      {pathForSharing && pathForSharing !== \"\" && (\n        <div>\n          <FacebookShareButton url={pathForSharing}>\n            <FacebookIcon size={32} round />\n          </FacebookShareButton>\n          <TwitterShareButton url={pathForSharing}>\n            <TwitterIcon size={32} round />\n          </TwitterShareButton>\n          <EmailShareButton url={pathForSharing}>\n            <EmailIcon size={32} round />\n          </EmailShareButton>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Editor;\n","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/routing/PrivateRoute.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/MemeGenerator.js",["90","91","92","93"],"/**\n * This is the main screen that is shown to the user.\n * It loads several components with the different functionalities we need for our Meme Generator.\n */\n\n// React imports\nimport { useState, useEffect, useCallback } from \"react\";\nimport axios from \"axios\";\nimport SpeechRecognition, {\n  useSpeechRecognition,\n} from \"react-speech-recognition\"; // We are using the following speech reconition API: https://github.com/JamesBrill/react-speech-recognition/blob/master/docs/API.md\nimport { saveAs } from \"file-saver\";\n\n// Components\nimport Topbar from \"../Topbar\";\nimport TemplatePicker from \"../TemplatePicker\";\nimport Editor from \"../Editor\";\nimport MemeHistory from \"../MemeHistory\";\nimport TemplateOverview from \"../TemplateOverview\";\nimport ImgFlipTemplates from \"../ImgFlipTemplates\";\nimport Charts from \"../Charts\";\nimport { NotificationManager } from \"react-notifications\";\nimport \"react-notifications/lib/notifications.css\";\n\n// MaterialUI | Source: https://material-ui.com/getting-started/installation/\n// For building our Frontend UI, we used Material UI Grid Layout and structured the whole page according to Grid containers and Paper boxes.\nimport { Grid, Paper, Typography, Box, Button } from \"@material-ui/core\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport ArrowBackIcon from \"@material-ui/icons/ArrowBack\";\nimport ArrowForwardIcon from \"@material-ui/icons/ArrowForward\";\n\n// style classes for the Material UI components\nconst useStyles = makeStyles((theme) => ({\n  grid: {\n    width: \"100%\",\n    height: \"100%\",\n    margin: \"0px\",\n  },\n  root: {\n    flexGrow: 1,\n    height: \"100%\",\n  },\n  paper: {\n    padding: theme.spacing(2),\n    textAlign: \"center\",\n    color: theme.palette.text.secondary,\n  },\n  scroll: {\n    overflow: \"scroll\",\n    height: \"1500px\",\n  },\n  scroll2: {\n    overflow: \"scroll\",\n    height: \"800px\",\n  },\n  search: {\n    overflow: \"scroll\",\n    height: \"430px\",\n  },\n  margin: {\n    margin: theme.spacing(1),\n  },\n  button: {\n    margin: theme.spacing(1),\n  },\n}));\n\nvar memeIndex = 0; //initially setting the memeIndex for the slider to 0\n\n// The history variable checks if the user is logged in.\nconst MemeGenerator = ({ history }) => {\n  const [error, setError] = useState(\"\");\n  const [privateData, setPrivateData] = useState(\"\");\n  const { transcript, resetTranscript } = useSpeechRecognition();\n  const PUBLIC_URL = \"http://localhost:3001\"; // For Zip download\n  // Template consts\n  const [templates, setTemplates] = useState([]); //is referred to the templates from the Imgflip API\n  const [template, setTemplate] = useState(null); //is referred to the meme template in the editor that can be edited\n  const [newMemeCreated, setNewMemeCreated] = useState(false);\n  const [newTemplateCreated, setNewTemplateCreated] = useState(false);\n\n  //This function is executed when the user clicks on the right arrow at the top of the editor\n  const clickRight = async () => {\n    const memeArrayRaw = await fetch(\"https://api.imgflip.com/get_memes\"); // get memes from the ImgFlip API\n    const {\n      data: { memes: memeArray }, // define a memeArray => Go into the object to get the data as we want the url\n    } = await memeArrayRaw.json();\n\n    memeIndex = memeIndex + 1;\n    const templateInfoForEditor = memeArray[memeIndex];\n    setTemplate(templateInfoForEditor);\n  };\n\n  //This function is executed when the user clicks on the left arrow at the top of the editor\n  const clickLeft = async () => {\n    const memeArrayRaw = await fetch(\"https://api.imgflip.com/get_memes\"); // get memes from the ImgFlip API\n    const {\n      data: { memes: memeArray }, // define a memeArray => Go into the object to get the data as we want the url\n    } = await memeArrayRaw.json();\n\n    if (memeIndex === 0) {\n      createNotification(\"firstTemplate\");\n      const templateInfoForEditor = memeArray[memeIndex];\n      setTemplate(templateInfoForEditor);\n    } else {\n      memeIndex = memeIndex - 1;\n      const templateInfoForEditor = memeArray[memeIndex];\n      setTemplate(templateInfoForEditor);\n    }\n  };\n\n  // Random Button to get a random ImgFlip template => Here, it is used for the Speech Recoginition Feature\n  const RandomTemplate = async () => {\n    const memeArrayRaw = await fetch(\"https://api.imgflip.com/get_memes\"); // get memes from the ImgFlip API\n    const {\n      data: { memes: memeArray }, // define a memeArray => Go into the object to get the data as we want the url\n    } = await memeArrayRaw.json();\n\n    const randomIndex = Math.floor(Math.random() * memeArray.length); // Generate a random number according to the size of the array (here it is 100 memes long)\n    const templateInfoForEditor = memeArray[randomIndex]; // The template will be the object at a random Index number of the Array.\n\n    setTemplate(templateInfoForEditor);\n  };\n\n  // Create notifications which are shown on the top right side of the  screen\n  const createNotification = (type) => {\n    console.log(\"type\", type);\n\n    switch (type) {\n      case \"firstTemplate\":\n        return NotificationManager.info(\n          \"You have already selected the first template\"\n        );\n\n      default:\n        return;\n    }\n  };\n\n  // First attempt tobuild function of download .zip-File of all saved Memes\n  // const saveFile = () => {\n  //   saveAs(\n  //     PUBLIC_URL + \"/public/zip/allmemes.zip\",\n  //     \"allmemes.zip\"\n  //   );\n  //   console.log(saveFile);\n  //   }\n\n  // Second attempt tobuild function of download .zip-File of all saved Memes\n  // get .zip-File from server using axios\n  const getDownloadFile = async () => {\n    return axios\n      .get(PUBLIC_URL + \"/zip/allmemes.zip\", {\n        responseType: \"application/file\",\n      })\n      .then((response) => response.zipFile());\n  };\n\n  // download .zip-File from server\n  const saveFile = () => {\n    getDownloadFile().then((zipFile) => saveAs(zipFile, \"allmemes.zip\"));\n  };\n\n  // Third attempt of .zip-download\n  // saveFile = () => {\n  //   fetch((PUBLIC_URL + '/zip/allmemes.zip')\n  //     .then(response => {\n  //       response.blob().then(blob => {\n  //         let url = window.URL.createObjectURL(blob);\n  //         let a = document.createElement('a');\n  //         a.href = url;\n  //         a.download = 'allmemes.zip';\n  //         a.click();\n  //       });\n  //       //window.location.href = response.url;\n  //   }));\n  // }\n\n  const classes = useStyles(); // const classes is created, which refers to useStyles (Material UI styles)\n\n  // Here, we get the images from the Imgflip API through a backend request, it can be found in the routes folder\n  useEffect(() => {\n    fetch(\"http://localhost:3001/memes\")\n      .then((x) => x.json())\n      .then((response) => setTemplates(response.data.memes));\n  }, []);\n\n  useEffect(() => {\n    // if no Token, automatically redirect due to no allowance for private route\n    if (!localStorage.getItem(\"authToken\")) {\n      history.push(\"/login\");\n    }\n    // Checks if the user is logged in\n    const fetchPrivateDate = async () => {\n      const config = {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          // Pass in Authorization Token\n          Authorization: `Bearer ${localStorage.getItem(\"authToken\")}`,\n        },\n      };\n      // Private Route\n      try {\n        const { data } = await axios.get(\"/api/private\", config);\n        setPrivateData(data.data);\n      } catch (error) {\n        localStorage.removeItem(\"authToken\");\n        setError(\"You are not authorized please refresh and login\");\n      }\n    };\n\n    fetchPrivateDate();\n  }, [history]);\n\n  // Here, we initialize the Listening function of our Speech Reconition\n  // SOurce: https://www.youtube.com/watch?v=08oWSkFQUF0&t=20s\n  // Note: useCallback will return a memorized version of the callback that only changes if one of the dependencies has changed\n  // We include \"switch\" to handle all the cases that can be initialized via Speech recoginition\n  const handleListening = useCallback(() => {\n    switch (transcript) {\n      case \"next\":\n        clickRight(memeIndex + 1); // click right when the user says \"next\"\n        resetTranscript(); // reset Transcript neeeds to be added after each case to \"restart\" the Transcript, otherwise it will just append the \"next\" one after another and not do any action.\n        break; // break at the end of each block => if the case appies then the function stops here\n      case \"previous\":\n        clickLeft(memeIndex - 1); // click left when the user says \"previous\"\n        resetTranscript();\n        break;\n      case \"random\":\n        RandomTemplate();\n        resetTranscript();\n        break;\n      default:\n        // default comes at the end of the switch function. NOTE: Append new cases BEFORE default.\n        resetTranscript(); // reset also as the default case of the Transcript\n        break;\n    }\n    console.log(transcript);\n  }, [clickRight, clickLeft, RandomTemplate]);\n\n  // Here, we start the voice recoginition => We start using the Speech Recogition API. It needs to be async because you have to wait for the promise, which in this case is the transcript data of the browser.\n  const initializeVoiceRecog = async () => {\n    try {\n      if (SpeechRecognition) {\n        const recognitionStarted = await SpeechRecognition.startListening({\n          language: \"en-US\",\n          continuous: true,\n        });\n        console.log(\"recognitionStarted\", recognitionStarted);\n      }\n    } catch (err) {\n      console.log(\"err\", err);\n    }\n  };\n\n  useEffect(() => {\n    initializeVoiceRecog();\n  }, []); // only call it at the beginning, this is why the dependency array is empty => Initialize\n\n  useEffect(() => {\n    if (transcript) handleListening(); // Check if there is a new transcript\n  }, [transcript]); // Only call if there is a transcprit => depedency\n\n  // Webapp user interface\n  return error ? (\n    <span className=\"error-message\">{error}</span>\n  ) : (\n    <>\n      <div style={{ textAlign: \"center\" }}>\n        <div className={classes.root}>\n          <Grid container spacing={2} direction=\"row\" alignItems=\"stretch\">\n            <Grid item xs={12}>\n              <Paper className={classes.paper} elevation={3}>\n                <Topbar></Topbar>\n              </Paper>\n            </Grid>\n          </Grid>\n\n          <Grid container spacing={2} direction=\"row\">\n            <Grid item xs={3}>\n              <Paper className={classes.paper} elevation={3} position=\"fixed\">\n                <div elevation={3} className={classes.scroll}>\n                  {/* Get MEMES for the sidebar with Searchbar*/}\n                  <Grid container spacing={3}>\n                    <Grid item sm={3} elevation={3}>\n                      <ImgFlipTemplates\n                        setTemplateInEditor={(img) => setTemplate(img)}\n                      ></ImgFlipTemplates>\n                    </Grid>\n                  </Grid>\n                </div>\n              </Paper>\n            </Grid>\n            <Grid item xs={6} className={classes.grid}>\n              <Grid container spacing={1} direction=\"row\">\n                <Grid item xs={12}>\n                  <Paper\n                    className={classes.paper}\n                    elevation={3}\n                    position=\"center\"\n                  >\n                    {/* Meme Editor */}\n                    <Typography variant=\"h5\" color=\"primary\">\n                      EDITOR\n                    </Typography>\n                    <p />\n                    <Box>\n                      {/* Image Slider */}\n                      <Button\n                        variant=\"contained\"\n                        size=\"medium\"\n                        onClick={clickLeft}\n                        startIcon={<ArrowBackIcon />}\n                        className={classes.button}\n                      >\n                        Previous Template\n                      </Button>\n                      <Button\n                        variant=\"contained\"\n                        size=\"medium\"\n                        onClick={clickRight}\n                        endIcon={<ArrowForwardIcon />}\n                        className={classes.button}\n                      >\n                        Next Template\n                      </Button>\n                      <p />\n                      <Editor\n                        memeToEdit={template}\n                        handleReloadMemes={(bool) => setNewMemeCreated(bool)}\n                      ></Editor>\n                    </Box>\n                  </Paper>\n                </Grid>\n                <Grid item xs={6}>\n                  <Paper\n                    className={classes.paper}\n                    elevation={3}\n                    position=\"fixed\"\n                  >\n                    {/* All Memes */}\n                    <Typography variant=\"h5\" color=\"primary\">\n                      ALL MEMES\n                    </Typography>\n                    <Button className={classes.button} onClick={saveFile}>\n                      Download .zip-File\n                    </Button>\n                    <br></br>\n                    <div elevation={3} className={classes.scroll2}>\n                      {/* <AutoPlayMethods> */}\n                      <MemeHistory\n                        setShouldReloadSavedMemes={(bool) =>\n                          setNewMemeCreated(bool)\n                        }\n                        shouldReloadSavedMemes={newMemeCreated}\n                        setTemplateInEditor={(img) => {\n                          setTemplate(img);\n                        }}\n                      />\n                      {/* </AutoPlayMethods> */}\n                    </div>\n                  </Paper>\n                </Grid>\n                <Grid item xs={6}>\n                  <Paper className={classes.paper} elevation={3}>\n                    {/* Your Templates */}\n                    <Typography variant=\"h5\" color=\"primary\">\n                      YOUR CUSTOM TEMPLATES\n                    </Typography>\n                    <div elevation={3} className={classes.scroll2}>\n                      <TemplateOverview\n                        setShouldReloadSavedTemplates={(bool) =>\n                          setNewTemplateCreated(bool)\n                        }\n                        shouldReloadSavedTemplates={newTemplateCreated}\n                        setTemplateInEditor={(img) => {\n                          setTemplate(img);\n                        }}\n                      />\n                    </div>\n                  </Paper>\n                </Grid>\n              </Grid>\n            </Grid>\n            <Grid item xs={3}>\n              <Paper className={classes.paper} elevation={3}>\n                {/* Settings */}\n                <Typography variant=\"h5\" color=\"primary\">\n                  OPTIONS\n                </Typography>\n                <TemplatePicker\n                  setShouldReloadSavedTemplates={(bool) =>\n                    setNewTemplateCreated(bool)\n                  }\n                  // passing our uploaded image up to the App.js, to pass it down to the Meme component\n                  setTemplateInEditor={(infoForEditor) =>\n                    setTemplate(infoForEditor)\n                  }\n                ></TemplatePicker>\n              </Paper>\n            </Grid>\n          </Grid>\n          <Grid item xs={12}>\n            <Paper className={classes.paper} elevation={3}>\n            <Typography variant=\"h5\" color=\"primary\">\n                  STATISTICS OF MEMES\n                </Typography>\n              <Charts />\n            </Paper>\n          </Grid>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default MemeGenerator;\n","/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Information.js",[],["94","95"],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Autoplay/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/RegisterScreen/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/LoginScreen/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/ResetPasswordScreen/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/screens/ForgotPasswordScreen/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/ImgFlipTemplates/index.js",[],"/Users/klaudiaguzij/KlaudiCoding/LMU/omm_reactmemegenerator/reactmemegenerator/src/components/Charts/index.js",["96"],"/**\n * This component displays statistical charts of likes and views of all generated memes.\n */\nimport React, { useState, useEffect } from \"react\";\nimport { Chart } from \"react-google-charts\"; //Source: https://www.npmjs.com/package/react-google-charts\n\nconst Charts = (props) => {\n  const [memesFromDatabase, setMemesFromDatabase] = useState();\n\n  // using our API to get Memes saved in our MongoDB\n  const loadSavedMemesFromServer = async () => {\n    fetch(\"http://localhost:3001/memes/get_memes\")\n      .then((x) => x.json())\n      .then((response) => setMemesFromDatabase(response));\n  };\n\n  useEffect(() => {\n    loadSavedMemesFromServer();\n  }, []);\n\n  // Webapp interface of the Charts Component\n  const renderCharts = () => {\n    if (!memesFromDatabase) return <p>No Memes yet.</p>;\n    return memesFromDatabase.map((meme) => {\n      const templateForEditor = {\n        url: meme.exported_image,\n        name: meme.name,\n        title: meme.title,\n        topText: meme.topText,\n        bottomText: meme.bottomText,\n        additionalTextA: meme.AdditionalTextA,\n        views: meme.views,\n        likes: meme.likes,\n        filePath: \"http://localhost:3001\" + meme.filePath,\n      };\n      return (\n        <Chart\n          width={\"300px\"}\n          height={\"300px\"}\n          chartType=\"Bar\"\n          loader={<div>Loading Chart</div>}\n          data={[\n            [\"Memes\", \"Views\", \"Likes\"],\n            [meme.title, meme.views, meme.likes],\n          ]}\n          options={{\n            // Material design options\n            chart: {\n              title: meme.title,\n              subtitle: \"Views and Likes\",\n            },\n          }}\n        />\n      );\n    });\n  };\n\n  return <div>{renderCharts()}</div>;\n};\nexport default Charts;\n",{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","replacedBy":"100"},{"ruleId":"101","severity":1,"message":"102","line":54,"column":10,"nodeType":"103","messageId":"104","endLine":54,"endColumn":19},{"ruleId":"101","severity":1,"message":"105","line":73,"column":10,"nodeType":"103","messageId":"104","endLine":73,"endColumn":21},{"ruleId":"101","severity":1,"message":"102","line":77,"column":10,"nodeType":"103","messageId":"104","endLine":77,"endColumn":19},{"ruleId":"106","severity":1,"message":"107","line":239,"column":6,"nodeType":"108","endLine":239,"endColumn":45,"suggestions":"109"},{"ruleId":"106","severity":1,"message":"110","line":262,"column":6,"nodeType":"108","endLine":262,"endColumn":18,"suggestions":"111"},{"ruleId":"97","replacedBy":"112"},{"ruleId":"99","replacedBy":"113"},{"ruleId":"101","severity":1,"message":"114","line":25,"column":13,"nodeType":"103","messageId":"104","endLine":25,"endColumn":30},"no-native-reassign",["115"],"no-negated-in-lhs",["116"],"no-unused-vars","'templates' is assigned a value but never used.","Identifier","unusedVar","'privateData' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useCallback has missing dependencies: 'resetTranscript' and 'transcript'. Either include them or remove the dependency array.","ArrayExpression",["117"],"React Hook useEffect has a missing dependency: 'handleListening'. Either include it or remove the dependency array.",["118"],["115"],["116"],"'templateForEditor' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"119","fix":"120"},{"desc":"121","fix":"122"},"Update the dependencies array to be: [transcript, resetTranscript, clickLeft]",{"range":"123","text":"124"},"Update the dependencies array to be: [handleListening, transcript]",{"range":"125","text":"126"},[8856,8895],"[transcript, resetTranscript, clickLeft]",[9724,9736],"[handleListening, transcript]"]